# 지영준 202130230  
## 4월 5일 강의 내용


## 3월 29일 강의  
1교시
1. System.in  
* 키보드 장치와 직접 연결되는 **표준 입력 스트림** 객체로, 키 값 바이트 정보로 바꾸어 제공하는 저수준 스트림이다.  
2. Scanner  
* System.in으로 하여금 키보드로부터 입력을 받게 하고, System.in이 반황하는 바이트 스트림을 응용프로그램의 입맛에 따라 문자, 문자열, 정수, 실수 등으로 변환하여 리턴한다.  
3. inport  
* Scanner 클래스의 경로명이 java.util.Scanner임을 알려준다. 
* Scanner 클래스는 사영자가 입력하는 키 값을 공백('\f', '\r',' ', '\n')으로 구분되는 **토큰 단위**로 읽는다.  
---
4. 식과 연산자  
* 주어진 식을 계산하여 결과를 얻어내는 과정을 **연산**이라고 한다.  
5. 산술 연산  
* 산술 연산자는 더하기(+), 뺴기(-), 곱하기(x), 나누기(/), 나머지(%)의 5개이다.  
6. 증간 연산  
* 증간 연산자는 ++,--의 두가지이며, 피연산자의 앞 또는 뒤에 붙어 값을 1증가시키거나 1감소시킨다.(i++,i--,++i,--i)  
7. 대입 연산  
* 연산자의 오른쪽 식의 결과를 왼쪽에 있는 변수에 대입한다.  
```  
a=b : b의 값을 a에 대입  a&=b : a=a&b와 동일
a+=b : a=a+b와 동일  a^=b : a=a^b와 동일
a-=b : a=a-b와 동일  a|=b : a=a|b와 동일
a*=b : a=a*b와 동일  a<<=b : a=a<<b와 동일
a/=b : a=a/b와 동일  a>>=b : a=a>>와 동일
a%=b : a=a%b와 동일  a>>>=b : a=a>>>b와 동일  
```  
8. 비교연산, 논리 연산
* 두개의 피연산자를 비교하여 true 또는 false의 논리 결과를 내는 연산자.  
* 논리 값을 대상으로 AND, OR, XOR, NOT의 논리 연산을 하여 논리 값을 내는 연산자이다.  
9. 조건 연산
* 피연산자로 구성되어 삼항 연산자라고도 한다.  
10. 비트 연산  
* 비트끼리 AND, OR, XOR, NOT연산을 하는 비트 논리 연산과, 비트를 오른쪽이나 왼쪽으로 이동시키는 비트 시프트 연산이 있다.  
---  
1. 조건문  
* 조건문을 이용하면 조건의 참 거짓에 따라 서로 다른 작업을 수행할 수 있다.  
2. if-else 문  
* if의 '조건식'이 참인 경우와 거짓인 경우에 실행할 문장을 각각 지시한다.  
3. 다중 if-else 문  
* '조건식'이 탐인 경우, 새당하는 '실행 문장'을 실행한 후 다중 if-else 전체를 벗어난다.  
4. switch 문  
* 값과 일치하는 case 문으로 분개한다.  
* case문의 '실행 문장'을 실행한 후 break를 만나면 switch 문을 벗어난다.  
* 어떤 case 문의 값과도 같지 않은 경우, dafault 문으로 분기하여 '실행 문장 n'을 실행한다.  
5. case 문에 지졍하는 값은 **정수 리터럴**, **문자 리터럴**, **문자열 리터럴**만 혀용한다.  
---
 3장 반복문  
1. for 문  
* 가장 많이 사용되는 for 문의 구성  
2. while문  
* true인 경우 반복이 계속되며, false인 경우 while 문을 벗어난다.  
3. do-while 문  
* '작업문' 실행 후 반복 조건을 따지므로, '작업문이' 최초 한번은 반드리 실행된다.  
4. 중첩 반복  
* 반복문 안에 다른 반목문을 만들 후 있다.  
5. continue 문  
* 반복문으 빠져나가지 않으면서 즉시 다음 반복으로 넘어가고자 할 때 사용.  
6. break 문  
* 반복문을 즉시 벗어날 때 사용.
* 중첩 반복의 경우 안쪽 반복문에서 break 문이 실행되면, 안똑 반복문만 벗어나며 바깥 쪽 반복문 내에서 실행 유지된다.  
7. 배열  
* 인덱스와 인덱스에 대응하는 인련의 데이터들로 이루어진 연속적인 자료구조  
* 배열에는 같은 종류의 데이터들이 순차적으로 저장된다.  
8. 배열 선언 및 생성  
* C/C+와 달리 레퍼런스 변수 선언과 배열 생성의두 단계가 필요하다
```  
    1.배연셍성
    :배열 공간을 할당받는 과정이다. 
    2.배열 초기화 
    :배열 선언문에서'{ }' 사이에 원소를 나여라여 초리과된 배열을 만들 수 있다.  
```  
9. 배열 인덱스와 배열 원소 접근  
* 배열의 인덱스는 정수만 가능하다.
* 인덱스는 0부터 시작하며 마지막 원소의 인덱스는 {배열 크기-1}이다.  
10. 레퍼런스 치환과 배역 공유  
* 레퍼런스 변수가 분리되어 있기 때문에 생성된 배열에 대한 공유가 쉽게 이루어진다.
11. 배열의 크기, length 필드  
* 자바는 배열을 객체로 다룬다.  
* 배열 공간과 함께 배열의 키기 값을 가진 length 필드가 배열 객체 내에 생성된다.  
* length 필드를 이용하면 프로그램에서 배열의 키기를 따로 관리할 필요가 없다.  
12. 배열과 for-each 문  
* for문을 변형한 for-each 문은 배열이나 나열의 크기만큼 루프를 돌면서, 각 원소를 순차적으로 접근하는데 매우 유용한다.
13. 2차원 배열  
``` java
int intArray[][]; 또는 [][] intArray;
int intArray = new int[2][5];
int intArray[][] = new int[2][5];
```  
14. 2차원 배열의 초기화  
* 2차원 배열을 선언항 때 각 원소를 초기화할 수 있다. 이때 자동으로 초기화된 배열이 생성된다.  
``` java  
int intArray[][] = { {0,1,2}, {3,4,5}, {6,7,8} };
char charArray[][] = { {'a','b','c'}, {'d','e','f'} };
double doubleArray[][] = { {0.01,0.02}, {0.03,0.04} };
```  
## 3월 22일 강의
* 1교시
1. Git Graph에서 버전을 설정한다.  
2. ctrl + shipt + p 를 눌러서 > java pro를 입력한 다음에 java 프로잭트를 생성한다  
3. 폴더를 선택한다.  
4. 프로젝트 이름을 입력한다. 
5. README.md를 제외한 폴더 4개를 복사한다.  
6. 소스코드를 새롭게 만들고 코드를 작성한다.  
---  
* 2교시  

 1장
1. 프로그래밍 언어의 설명 (교재p19참고)  
    * 기계어  
    * 어셈블리어  
    * 고급언어  
2. 프로그래밍 언어 진화 과정 (교재p19참고)  
3. 프로그래밍과 컴파일  
    * 소스 : 프로그래밍 언어로 작성된 텍스트 파일  
    * 컴파일 : 소스파일을 컴퓨터로 번역하는 것  
4. 자바의 태동  (교재 p21 참고)  
---
5. 자바의 플랫폼 독립성,WORA  
    * WORA : 한번 작성된 코드는 모든 플랫폼에서 바로 실행되는 자바의 특증  
    * C/C++들 기존언어가 가진 플랫폼 종속성 극복  
    * 네트워크에 연결된 어느 클라이언트에서나 실행  
 ---
6. WORA를 가능하게하는 자바의 특징(교재p23참고)  
---
7. 바이트 코드   
    * 자바 컴파일러가 자바 소스 프로그램을 컴파일한 일종의 기계어로서, 자바 가상기계에 의해 실행되는 바이너리 코드이다.  
---
8. 자바 응용프로그램 실행 환경 (교재 p25 참고)
---

9. JDK, JRE  
    * Jdk : 자바 응용 개발 환경, 개발에 필요한 도구 포함  
    * JRE : 자바 응용프로그램이 싱행된때 필요한 소프트웨어들로 개발자가 활용할 수 있는 자바 API와 자바 가상기계를 포함한다.  
---
10. 자바의 특징  

    * 플랫폼 독림성  
    : 자바는 하드웨어, 운영체제 등 플랫폼에 좃속된지 않는 독림적인 바이트 코드로 컴파일되며 자바 가상 기계만 있으면 하드웨어/운영체제를 막론하고 자바 프로그램의 실행이 가능하다.  
    ---
    * 객체 지향  
    : 자바는 객체 지향 언어로서 캡슐화, 상속 다형성 등을 지원한다. 객체 지향 프로그램은 해곃할 과제를 실제 세상의 객체 간의 상호 관계로 모델링하여 인간의 사고에 가깝게 표현한다.  
    ---
    * 클래스로 캡슐화  
    : 자바는 객체 지향 언어의 캡슐화 원칙을 철저히 지켜, 변수나 메소드는 반드시 클래스 내에 구현하도록 한다. 클래스에 속하지 않은 변수나 메소드는 있을수 없다. 자바는 클래스 안에 새로운 클래스, 즉 **내부 클래스**를 만들 수 있다.  
    ---
    * 소스와 클래스 파일  
    자바 소스가 컴파일된 클래스 파일(.Calss)에는 반드시 하나의 자바 클래스만이 들어있다. 그러므로 하나의 자바 소스 파일에 여러 개의 클래스를 작성한 경우, 컴파일하면 클래스마다 별도의 클래스 파일이 생성된다.  
    ---  
    11. 자바 에센셜  
    * 실행 코드 배포 : 자바 응용프로그램은 한 개의 클래스 파일 또는 다수의 클래스 파일로 구성된다.  
    * 패키지 : 서로 관련 있는 클래스는 패키지로 묶어 관리한다.  
    * 멀티스레드 : 하나의 자바 프로그램에서 다수의 스레드가 동시에 실행할 수 있는 환경을 지원한다.  
    * 가비지 컬랜션 : 자바 언어는 메머리를 할당받는 기능은 있지만, 메모리를 반환하는 기능은 없다.프로그램 내에 사용되지 않는 메모리는 자바 가상 기계의 가비지 컬렉션 기능에 의해 자동으로 회수한다.  
    ---
    (단점)  
    * 실시간 응용 시스템에 부적합 : 자바 응용프로그램은 실행 도중 예측할 수 없는 시점에 가비지 컬렉션이 실행되므로, 프로그램 실행이 일시적으로 중단된다.  
    * 자바 프로그램은 안전하다 : 자바 언어는 타임 체크가 매우 엄격하며, C.C++와 달리 메모리의 물러적 주소를 사용하는 포인터의 개념이 없기 때문에, 잘못된 자바 프로그램으로 인해 컴퓨터 시스템이 중단되는 일은 없다.  
    * 프로그램 작성이 쉽다 : 프로그맴 개발을 귑게 도와주는 다양한 라이브러리와 스윙 등 강력한 GUI 라이브러리를 자원하므로 프로그램 작성이 빠르고 쉽다.  
    * 싱행곳도를 개선하기 위해 JIT 컴파일러가 사용된다 : 자바는 바이트 코드를 인터프리터 방식으로 실행한다.  

2장  
1. 클래스 만들기  
    * 자바에서는 클래스를 만들고, 그 안에 변수, 상수, 함수(메소드) 등 모든 프로그램 요소를 작성한다.  
2. 주석문  
    * 개발자가 프로그램에 대한 설명이나 특이 사항 등을 자우롭게 덧붙일 때 사용한다.      
    // : 한 라인 주석, 행이 끝날 때까지 주석으로 처리  
    /*  
    : 여러 라인 주석으로 /* 와 */로 구성  
    .............  
    */  
3. main()메소드  
    * 자바 프로그램은 main()메소드에서부터 실행을 시작한다.  
4. 메소드
    * C/C++함수를 자바에서는 메소드라고 부르며, 작성 방법이나 호풀 방법은 C/C++ 함수와 거의 같지만, 반드시 클래스 내에 작성되어야 한다.
5. 메소드 호출
    * 다음은 변수 1의 값과 정수 10을 매개변수로 넘겨주는 sum() 호출문의 사례이다.  
    [s=sum(i,10);  // sum() 메소드의 매개변수 n, m에 각각 i 값과 10 전달]  
6. 변수 선언  
    * 변수란 데이터를 저장하는 공간이며 사용 밒 선언 방법이 C/C++와 동일하다.  
7. 문장  
    * 자바에서 모든 문장은 C/C++와 동일하게 다음과 같이 ';'로 끝나야 한다.  
    **[ int i=10;  
    s = sum(i,10); ]**  
8. 화면출력  
    * 정수,문자,문자열 등 데이터를 출력하기 위해  
    System.out.println();를 이용한다  

2-2장  
1. 식별자 이름 규칙  
:자바에서 식별장=를 만들때 다음 구칙을 준수하여야 한다.  
* 특수문자( % , * , & , @ , ^ 등), 공백(탭 , space 등)은 식별자로 사용할 수 없으나 '_','$'는 예외다.  
* 식별자로 한글을 사용할 수 있다.  
if, while, class등 자바 언어의 키워드는 식별자로 사용할 수 없다.  
* 식별자의 첫 번째 문자로 숫자는 사용할 수 없다.  
* true, false, null은 식별자로 사용할 수 없다.  
대소문자를 구별한다.  
* 길이 제한이 없다.  

2-3장  

2. 데이터 타임이란 자바에서 다룰 수 있는 데이터의 종류를 말한다.  
    레퍼런스란 C/C++의 포인터와 비슷한 개념이다.  
    * 기본타입 : boolean, char, short, int, long, float, double  
    * 레퍼런스 타입 : 레퍼런스 타입은 한 가지이지만 다음 세경우로 이용한다.  
    1. 배열에 대한 레퍼런스  
    2. 클래스에 대한 레퍼런스  
    3. 인터헤이스에 대한 레퍼런스  
3. 자바의 기본 타입  
    * 자바의 기본 타입과 메모리 공간, 데이터 값의 범위를 보여준다.  
    1. 정수 타입 : byte, short, int, long  
    2. 실수 타입 : float, double  
    3. 문자 char 타입 : 2바이트  
4. 문자열  
    * 자바에서 문자열은 기본 타입에 속하지 않으며, JDK에서 제공하는 String 클래스를 이용한다.  
    * 자바에서 다음과 같이 문자열과 기본 타입의 + 연산으로 문자열을 연결한 새로운 문자열을 생성한다.  
5. 변수와 선언  
    * 변수는 데이터를 저장하는 공간이다. 따라서 변수를 선언하면 변수의 타입 크기에 맞는 메모리 공간이 할당된다.  
6. 리터럴  
    * 리터럴이란 프로그램에 직접 표현한 값을 말한다. 정수, 실수, 문자, 논리, 문자열 타입 모두 리터럴이 있다.  
    1. 정수 리터럴 : 정수 리터럴은 4가지 유형이 있으며 변수와 함께 사용한다.  
    **int n = 15; // 십진수 15  
    int m = 015; // 015는 8진수로서 십진수 13  
    int k = 0x15; // 0x15는 16진수로서 십진수 21  
    int b = 0b0101; // 0b0101은 2진수로서 십진수 5**  
    2. 실수 리터럴 : 실수 리터럴은 소수점 형재나 지수 형태로 실수를 표현한 값 이다.  
    **12 .  12.0 .1234 0.1234 1234E-4**  
    * 실수리터럴은 double 타입으로 자동 처리  
    * 숫자 위에 f 또는 F를 붘이면 float 타입, d 또는 D를 붙이면 double 타입으로 강제 변환  
    3. 문자 리터럴 : 문자 리터럴은 단일 인용부호('')로 문자를 표현하거나 \n 다음에 문자의 유니코드 값을 사용하여 표현  
    'a','w','가','*','3','글'  
    * 특수문자 리터럴  


## 3월 15일 강의  
내용정리

## 3월 8일 강의
# markdown-문법-정리  
# h1
## h2
### h3
#### h4
##### h5
###### h6
일반 글씨는 h4정도 크기  <br><br>
크기개행(newline)을 할때는 스페이스 2개  
  
 *이탤릭체*  
 **굵게**  
***이텔릭+굵게***  
  
# 리스트  
1. 첫 번째  
2. 두 번째  
3. 세 번째  
  
* 첫 번째  
    * 두 번째  
        * 세 번째  
  
# 코드 블럭  
```java
public class Main { 
    public static void main(String[] args) { 
        System.out.println("Hello World"); 
   }
}
```  
# 링크  
[구글 링크](https://www.google.com)  
[폰트 관련 명령](#markdown-문법-정리)  
![상대경로](./20210525051115632cebl.jpg)  
![절대경로](https://th.bing.com/th/id/OIP.aSM0l666ifQ_2L0uu13zIgHaIH?rs=1&pid=ImgDetMain)  
  
# 라인  
---  
***  
